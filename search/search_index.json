{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"django-brackets","text":""},{"location":"#mixins-to-make-djangos-class-based-views-simpler-and-neater","title":"Mixins to make Django's Class-based Views Simpler and Neater","text":"<p><code>django-brackets</code> is a library of mixins to make using class-based views easier. Yes, it's a lot like <code>django-braces</code>; it should, we wrote them both. In fact, most of <code>django-brackets</code> comes from a rewrite of <code>django-braces</code> that was just too big and breaking.</p> <p>Use these mixins as inspiration for your own, as well! The <code>PassesTestMixin</code> is used, for example, to build all of the Access mixins. You can use it to make your own mixins that require a request to pass some arbitrary test!</p> <p>As you'll see in our contribution guide, we also love contributions. Send your mixins in today!</p>"},{"location":"#installation-and-usage","title":"Installation and usage","text":"<p>You'll need to install <code>django-brackets</code> via <code>pip</code>: <code>pip install django-brackets</code>. You do not need to add <code>brackets</code> to your <code>INSTALLED_APPS</code> in order to use the mixins. In a <code>views.py</code> where you need a mixin, you'll import them like: <code>from brackets import mixins</code>.</p> <p>Mixins should be first in your inheritance tree, view classes last. For example:</p> <pre><code>from django.views import generic\nfrom brackets import mixins\n\nclass UserList(mixins.LoginRequiredMixin, generic.ListView):\n    ...\n</code></pre>"},{"location":"#mixins","title":"Mixins","text":""},{"location":"#http-and-request-related-mixins","title":"HTTP- and request-related mixins","text":"<p>These mixins are all related to authorizing and manipulating requests and responses.</p> <ul> <li>Access</li> <li>HTTP</li> <li>Redirects</li> </ul>"},{"location":"#databases-forms-and-serializers","title":"Databases, forms, and serializers","text":"<p>If your view queries the database, uses forms, or is a form and not a view at all, these mixins may come in handy.</p> <ul> <li>Queries</li> <li>Forms</li> <li>Form Views</li> </ul>"},{"location":"#apis","title":"APIs","text":"<p>Mixins related to Django REST Framework and others that don't have a better home.</p> <ul> <li>Django REST Framework</li> <li>Miscellaneous</li> </ul>"},{"location":"contribution_guide/","title":"Contributing","text":"<p>First of all, thank you for wanting to make <code>django-brackets</code> better! We love getting input and suggestions from the community. Secondly, we just want to put out a few ground rules for contributing so that we can get your pull requests in sooner and cause fewer headaches all around.</p>"},{"location":"contribution_guide/#installation","title":"Installation","text":"<p>When you want to install <code>django-brackets</code> for local development, first clone the project from GitHub. Secondly, install it as an editable package and install the testing and development dependencies: <code>pip install -e django-brackets[testing,development]</code>. You can test the project via <code>pytest</code> and check types with <code>mypy src</code>.</p>"},{"location":"contribution_guide/#code-of-conduct","title":"Code of Conduct","text":"<p>Any communication around <code>django-brackets</code>, any contribution, any issue, is under the guidelines of the Django code of conduct. We don't allow any form of hate or discrimination in this project.</p> <p>If you object to the code of conduct, you are not licensed to use this software.</p>"},{"location":"contribution_guide/#code-style","title":"Code Style","text":"<p>All contributions require certain formatting and checks before they can be accepted. Your PR should: - be formatted with <code>black</code> with an allowed line length of 99. - have docstrings for all files, classes, and functions. Use <code>interrogate</code> to verify your work. - be well-typed. We use <code>mypy</code> for static type checking. Run <code>mypy src</code> to check your types. - maintain or increase code coverage.</p>"},{"location":"contribution_guide/#tests","title":"Tests","text":"<p>Your PR should also be well-tested. We use the <code>pytest</code> testing framework and make heavy use of fixtures over mocks. We aim for 100% test coverage but we also recognize that 100% is a magic number and won't prevent all bugs. Still, makes refactors easier!</p> <p>We test <code>django-brackets</code> against the newest stable version of Python and the latest Long Term Support (LTS) release of Django. Other versions of Python and Django may work but are not tested against and, thus, unsupported.</p>"},{"location":"contribution_guide/#documentation","title":"Documentation","text":"<p>Documentation is one of the most important parts of any project. If you don't know how to use it, you probably won't. All PRs should come with corresponding documentation updates. New mixins should come with a usage example and documentation explaining the concept. We use Mkdocs for our documentation needs.</p>"},{"location":"contributors/","title":"Contributors","text":"<p>While we stand on the shoulders of many, many giants (some of whom are on the shoulders of giants themselves), the following people have directly contributed to the project.</p> <ul> <li>klove</li> <li>Everyone who contributed to <code>django-braces</code>.</li> </ul>"},{"location":"mixins/access/","title":"Access mixins","text":"<p>A lot of time is spent handling authentication and authorization in Django projects, from setting up your methods to special rules for special views. These mixins are aimed at making it easier to control access to your view.</p>"},{"location":"mixins/access/#passestestmixin","title":"PassesTestMixin","text":"<p>The <code>PassesTestMixin</code> is the base for most of the mixins in this module. It requires you to provide a method and that method's name. The view will run that method before anything happens in <code>dispatch</code>. If the test method returns <code>False</code> or an equivalent, the view's <code>dispatch</code> method will be skipped and the <code>handle_test_failure</code> method will be called. Override <code>handle_test_failure</code> to control what happens when the request doesn't pass your test.</p> <pre><code>from brackets.mixins import PassesTestMixin\n\n\nclass IndexView(PassesTestMixin, TemplateView):\n    dispatch_test = \"is_unchained\"\n\n    def is_unchained(self):\n        return not self.request.is_chained\n</code></pre> <p>The above view would require a request to have <code>is_chained</code> defined and falsey in order to pass and the view be executed. By overriding <code>get_test_method</code>, you can control how the dispatch test is discovered. Overriding <code>handle_test_failure</code> will let you customize what happens after a failed test.</p> <p>Using this mixin, you can create all of the other mixins in this module. That's what we did.</p>"},{"location":"mixins/access/#passorredirectmixin","title":"PassOrRedirectMixin","text":"<p>The <code>PassOrRedirectMixin</code> combines two powerful mixins: <code>PassesTestMixin</code> and the [<code>RedirectMixin</code>] from the redirect mixins.</p> <p>If the view's test doesn't pass, by default the request will be redirected to whatever URL you provide in the <code>redirect_url</code> attribute. If you'd like to control how the redirection is accomplished, override <code>redirect</code>. If you'd like to customize how the redirect URL is discovered, you'll want to override <code>get_redirect_url</code>.</p> <pre><code>from brackets.mixins import PassOrRedirectMixin\n\nclass InOrOutView(PassOrRedirectMixin, View):\n    redirect_url = \"/login/\"\n    redirect_unauthenticated_users = True\n</code></pre> <p>The <code>redirect_unauthenticated_users</code> attribute directs the mixin to either use the <code>redirect</code> method or to use whatever failure handler is next in the chain.</p>"},{"location":"mixins/access/#superuserrequiredmixin","title":"SuperuserRequiredMixin","text":"<p>The <code>SuperuserRequiredMixin</code> is a fairly unsurprising mixin. If the user requesting the view is not authenticated and a superuser, they're redirected elsewhere. You'll want to override the default <code>test_superuser</code> if you have a special way of determining user levels.</p> <pre><code>from brackets.mixins import SuperuserRequiredMixin\n\nclass PhoneBooth(SuperuserRequiredMixin, DetailView): ...\n</code></pre>"},{"location":"mixins/access/#staffuserrequiredmixin","title":"StaffUserRequiredMixin","text":"<p>Much like <code>SuperuserRequiredMixin</code>, the <code>StaffUserRequiredMixin</code> requires the view to be requested by a user where <code>is_staff</code> is <code>True</code>. If you need to customize this discovery, override <code>test_staffuser</code>.</p> <pre><code>from brackets.mixins import StaffUserRequiredMixin\n\nclass WizardInventory(StaffUserRequiredMixin, DetailView): ...\n</code></pre>"},{"location":"mixins/access/#grouprequiredmixin","title":"GroupRequiredMixin","text":"<p>The <code>GroupRequiredMixin</code> is a little different from <code>SuperuserRequired</code> and <code>StaffUserRequired</code>. It will take a single group name or a list of group names, and then ensure that the requesting user is in at least one of them.</p> <pre><code>from brackets.mixins import GroupRequiredMixin\n\nclass PrivateGroupView(GroupRequiredMixin, ListView):\n    group_required = \"private_group\"\n</code></pre> <p>Overriding <code>check_membership</code> will let you customize this membership requirement.</p>"},{"location":"mixins/access/#anonymousrequiredmixin","title":"AnonymousRequiredMixin","text":"<p>One of the simplest mixins, the <code>AnonymousRequiredMixin</code> redirects any requests coming from an authenticated user. This mixin is useful on views related to login or account creation, since there's little to no reason for an authenticated user to be on those pages.</p> <pre><code>from brackets.mixins import AnonymousUserMixin\n\nclass NewSubscriberBenefits(AnonymousUserRequiredMixin, DetailView): ...\n</code></pre>"},{"location":"mixins/access/#loginrequiredmixin","title":"LoginRequiredMixin","text":"<p>Much like the <code>AnonymousRequiredMixin</code>, the <code>LoginRequiredMixin</code> redirects any requests that aren't from an authenticated user.</p> <pre><code>from brackets.mixins import LoginRequiredMixin\n\nclass MembersOnly(LoginRequiredMixin, DetailView): ...\n</code></pre>"},{"location":"mixins/access/#recentloginrequiredmixin","title":"RecentLoginRequiredMixin","text":"<p>The <code>RecentLoginRequiredMixin</code> is exactly the same as the <code>LoginRequiredMixin</code> except that it checks the age of the user's authentication. Overriding <code>max_age</code> with a new value, in seconds, will allow you to control how long they can go between authentications.</p> <pre><code>from brackets.mixins import RecentLoginRequiredMixin\n\nclass MembersOnly(RecentLoginRequiredMixin, DetailView):\n    max_age: 3600  # They must login within the last hour\n</code></pre>"},{"location":"mixins/access/#permissionrequiredmixin","title":"PermissionRequiredMixin","text":"<p>The <code>PermissionRequiredMixin</code> is probably the most complex of the access-related mixins. Permissions are a very customizable system in Django. In this mixin, too, you're allowed to have optional and required permissions.</p> <p>The <code>permission_required</code> attribute is where most of the work is done. It's expected to be a dictionary with two keys: <code>\"all\"</code> and <code>\"any\"</code>. The <code>\"all\"</code> key indicates permissions which the user must have, and they must have all of them. The <code>\"any\"</code> list of permissions, though, will allow a user through if they have any of the listed permissions.</p> <pre><code>from brackets.mixins import PermissionRequiredMixin\n\nclass EditAccountView(PermissionRequiredMixin, UpdateView):\n    permission_required = {\n        \"all\": [\"account.can_edit\"],\n        \"any\": [\"account.can_manage\", \"account.can_administer\"]\n    }\n</code></pre> <p>The above view would require a user to have the <code>account.can_edit</code> permission. The user wouldn't have to have both the <code>account.can_manage</code> or <code>account.can_administer</code> permissions. In fact, they don't have to have either! <code>\"any\"</code> also allows for \"none\".</p>"},{"location":"mixins/access/#sslrequiredmixin","title":"SSLRequiredMixin","text":"<p>The <code>SSLRequiredMixin</code> only allows through requests that come from a secure connection. By default, requests are redirected to their <code>https</code> equivalent. You can control this by setting <code>redirect_to_ssl</code> to <code>False</code>; the view will now return a <code>BadRequest</code> instead of redirecting.</p> <pre><code>from brackets.mixins import RecentLoginRequiredMixin\n\nclass WeTakeSecuritySeriously(SSLRequiredMixin, TemplateView):\n    redirect_to_ssl = False\n</code></pre> <p>If you need to customize the redirection, override <code>handle_test_failure</code>.</p>"},{"location":"mixins/form_views/","title":"Form-related View Mixins","text":"<p>Many class-based views rely on forms to power them. Whether you're creating a new instance, editing an existing one, or accepting customer feedback, form views are your friend. The mixins in this module relate to these views.</p>"},{"location":"mixins/form_views/#csrfexemptmixin","title":"CSRFExemptMixin","text":"<p>This mixin marks a view as being exempt from CSRF checks. This is often handy for AJAX-related views.</p> <pre><code>from brackets.mixins import CSRFExemptMixin\n\nclass UnshieldedForm(CSRFExemptMixin, FormView): ...\n</code></pre>"},{"location":"mixins/form_views/#formwithusermixin","title":"FormWithUserMixin","text":"<p>The <code>FormWithUserMixin</code> provides a keyword argument to your form named <code>user</code>. This keyword argument's value is the <code>request.user</code>. Combine this mixin with the forms.UserFormMixin for best results.</p> <pre><code>from brackets.mixins import FormWithUserMixin\n\nclass UserForm(FormWithUserMixin, FormView): ...\n</code></pre>"},{"location":"mixins/form_views/#multipleformsmixin","title":"MultipleFormsMixin","text":"<p>If you've ever found yourself having to handle multiple Django forms in the same view, you know it can be a pain. This mixin aims to reduce or even remove that complexity completely.</p> <p>Three attributes have been added, with corresponding methods, that will allow you to configure your view. All are dictionaries where the key is used to refer to the form.</p> <pre><code>from brackets.mixins import MultipleFormMixin\n\nclass UserAndAccountView(MultipleFormMixin, FormView):\n    form_classes = {\"user\": UserForm, \"account\": AccountForm}\n    form_initial_values = {\"account_id\": 0}\n\n    def get_form_instances(self):\n        instances = super().get_form_instances()\n        intances.update({\"user\": self.request.user})\n        return instances\n</code></pre> <ul> <li><code>form_classes</code> values are the form classes themselves. Use   <code>get_form_classes</code> to provide form classes programmatically.</li> <li><code>form_initial_values</code> values are dictionaries of initial data for the   forms. You can also provide this dictionary via <code>get_initial</code></li> <li><code>form_instances</code> values are model instances to be provided to model   forms. Since this is usually more complicated, expect to override the   behavior in <code>get_instance</code>.</li> </ul>"},{"location":"mixins/forms/","title":"Form-related Mixins","text":"<p>The mixins in this module should be applied to a Django <code>Form</code>, not a view.</p>"},{"location":"mixins/forms/#userformmixin","title":"UserFormMixin","text":"<p>When the form is initialized, the \"user\" keyword argument will be popped off into the <code>self.user</code> name.</p> <pre><code>from brackets.mixins import UserFormMixin\n\nclass ProfileForm(UserFormMixin, ModelForm): ...\n</code></pre>"},{"location":"mixins/http/","title":"HTTP mixins","text":"<p>The HTTP mixins in <code>django-brackets</code> are meant to control the handling of HTTP beyond what Django already does in <code>dispatch</code>.</p>"},{"location":"mixins/http/#allverbsmixin","title":"AllVerbsMixin","text":"<p>The <code>AllVerbsMixin</code> allows you to create a view that responds with a single method, regardless of the HTTP verb (<code>GET</code>, <code>PUT</code>, etc) used in the request.</p> <pre><code>from brackets.mixins import AllVerbsMixin\n\nclass YouGetGET(AllVerbsMixin, TemplateView):\n    def all(self, request, *args, **kwargs):\n        return HttpResponse(\"Coming Soon\")\n</code></pre> <p>All requests for this view will receive the text \"Coming Soon\".</p>"},{"location":"mixins/http/#headermixin","title":"HeaderMixin","text":"<p>The <code>HeaderMixin</code> aims to make it easier to control arbitrary headers in a view's responses. You can provide the headers statically as the <code>headers</code> attribute or programmatically via <code>get_headers</code>.</p> <pre><code>from brackets.mixins import HeaderMixin\n\nclass SpecialHeaderMessage(HeaderMixin, TemplateView):\n    headers = {\"X-WITH-LOVE\": True}\n</code></pre>"},{"location":"mixins/http/#cachecontrolmixin","title":"CacheControlMixin","text":"<p>Controlling the caching of a response can be a complicated task. This mixin removes a lot of that complexity and makes cache control very customizable.</p> <pre><code>from brackets.mixins import CacheControlMixin\n\nclass AgesLikeWine(CacheControlMixin, TemplateView):\n    cache_control_max_age = 1_000_000_000\n</code></pre> <p>You can set the following attributes to control cache for your view:</p> <ul> <li><code>cache_control_public</code></li> <li><code>cache_control_private</code></li> <li><code>cache_control_no_cache</code></li> <li><code>cache_control_no_store</code></li> <li><code>cache_control_no_transform</code></li> <li><code>cache_control_must_revalidate</code></li> <li><code>cache_control_proxy_revalidate</code></li> <li><code>cache_control_max_age</code></li> <li><code>cache_control_s_maxage</code></li> </ul> <p>You can read more about caching and what these options relate to here, in the Django documentation.</p>"},{"location":"mixins/http/#nevercachemixin","title":"NeverCacheMixin","text":"<p>Similar to the <code>CacheControlMixin</code>, the <code>NeverCacheMixin</code> marks a view as being uncacheable. This is particularly useful on one-time-use pages.</p> <p>```py from brackets.mixins import NeverCacheMixin</p> <p>class GingerbreadMan(NeverCacheMixin, TemplateView): ...</p>"},{"location":"mixins/misc/","title":"Miscellaneous mixins","text":"<p>Sometimes mixins just don't have a good home.</p>"},{"location":"mixins/misc/#staticcontextmixin","title":"StaticContextMixin","text":"<p>This mixin allows you to set static values which will always be injected into the view's <code>context</code> that's used to render templates.</p> <pre><code>from brackets.mixins import StaticContextMixin\n\nclass WelcomePage(StaticContextMixin, TemplateView):\n    static_context = {\"greeting\": \"Go away\"}\n</code></pre> <p>If you'd like to provide your static context in a dynamic way...you can so by overriding the <code>get_static_context</code> method.</p>"},{"location":"mixins/queries/","title":"Query Mixins","text":"<p>All of the mixins in here relate to controlling the queries that your views make. Use these views to reduce the number of queries being ran.</p>"},{"location":"mixins/queries/#selectrelatedmixin","title":"SelectRelatedMixin","text":"<p>Adds <code>select_related</code> clauses to your query.</p> <pre><code>from brackets.mixins import SelectRelatedMixin\n\nclass SuperDetailView(SelectRelatedMixin, DetailView):\n    select_related = \"profile\"\n</code></pre> <p>You can select multiple fields by providing a list (e.g. <code>select_related = [\"profile\", \"pet_set\"]</code>).</p>"},{"location":"mixins/queries/#prefetchrelatedmixin","title":"PrefetchRelatedMixin","text":"<p>Much like the <code>SelectRelatedMixin</code>, the <code>PrefetchRelatedMixin</code> will add <code>prefetch_related</code> clauses into your query.</p> <pre><code>from brackets.mixins import PrefetchRelatedMixin\n\nclass SuperListView(PrefetchRelatedMixin, ListView):\n    prefetch_related = [\"user\", \"account\"]\n</code></pre> <p>You can provide a single field as a string.</p>"},{"location":"mixins/queries/#orderablelistmixin","title":"OrderableListMixin","text":"<p>The <code>OrderableListMixin</code> injects directives to order your queryset via your URL. An example might be a URL like <code>example.com/widgets/?order_by=manufacturer&amp;order_dir=desc</code>, which would order a page full of widgets by their manufacturer in descending order.</p> <pre><code>class SortYourselfOut(OrderableListMixin, ListView):\n    orderable_fields = [\"manufacturer\", \"make\", \"model\"]\n    orderable_field_default = \"make\"\n    orderable_direction_default = \"asc\"\n</code></pre>"},{"location":"mixins/redirects/","title":"Redirection Mixins","text":"<p>The mixins in this group are all related to redirecting HTTP requests.</p>"},{"location":"mixins/redirects/#redirectmixin","title":"RedirectMixin","text":"<p>This mixin provides a <code>redirect</code> method that can be used to redirect the request to another URL. You can provide the URL via the <code>redirect_url</code> attribute or by overriding the <code>get_redirect_url</code> method.</p> <pre><code>from brackets.mixins import RedirectMixin\n\nclass SeeYaLaterSucker(RedirectMixin, TemplateView):\n    redirect_url = \"youre/outta/here.html\"\n</code></pre>"},{"location":"mixins/redirects/#redirecttologinmixin","title":"RedirectToLoginMixin","text":"<p>This mixin is effectively the <code>RedirectMixin</code> with some preset behaviors. By default, it redirects to the login URL provided by Django, but you can override this with either the <code>login_url</code> attribute or the <code>get_login_url</code> method.</p> <pre><code>from brackets.mixins import RedirectToLoginMixin\n\nclass GetANameBadge(RedirectToLoginMixin, View):\n    login_url = \"/login\"\n</code></pre>"},{"location":"mixins/rest_framework/","title":"Django REST Framework mixins","text":"<p>Increasingly, if you use Django, you probably use Django REST Framework with it. These mixins will make working with DRF simpler.</p>"},{"location":"mixins/rest_framework/#multipleserializermixin","title":"MultipleSerializerMixin","text":"<p>This mixin, like the form_views.MultipleFormView allows you to specify, validate, and handle multiple serializers in a single view. Unlike that mixin, however, the serializers are assumed to be different based on the HTTP verb their view was requested by. You can override this by changing <code>get_serializer_class</code></p> <pre><code>from brackets.mixins import MultipleSerializersMixin\n\nclass SerialCereal(MultipleSerializersMixin, ViewSet):\n    serializer_classes = {\n        \"get\": FullSerializer,\n        \"post\": FullSerializerWithValidation\n    }\n</code></pre>"}]}